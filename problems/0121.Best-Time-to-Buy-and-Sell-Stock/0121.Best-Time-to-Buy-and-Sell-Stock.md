# [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/4034420/best-time-to-buy-and-sell-stock-python-easy-explanations/)

## Solution 1: Brute Force Search

### Intuition

For every sell position, check all previous possible buy positions and update maximum profit.

### Approach

1. Initialize `max_profit` as 0.
1. Iterate over `prices`  starting from index 1 (the first sell position).
1. In each iteration (sell position), check for all possible buy positions before the current index and if a higher profit is seen, update `max_profit`.
1. Finally, return `max_profit`.

### Code

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        max_profit = 0
        for sell in range(1, len(prices)):
            for buy in range(sell):
                max_profit = max(max_profit, prices[sell] - prices[buy])
        return max_profit
```

### Complexity

- Time complexity: $O(n^2)$

The total number of searches takes $O(1 + 2 + 3 + ... + n-1) = O(\frac{n(n-1)}{2}) = O(n^2)$ time.

- Space complexity: $O(1)$

Constant space used (only 1 variable required).

---

## Solution 2: Dynamic Programming (Kadane's Algorithm)

### Intuition

Transpose the problem into a [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/) problem by considering the day-to-day price differences. Then, use dynamic programming (Kadane's Algorithm) to find the maximum subarray and return the maximum sum.

### Approach

1. Initialize `current_max` and `max_profit` as 0.
1. Iterate over `prices` starting from index 1.
1. In each iteration:
    - Increment `current_max` with the difference of the current price and the previous day's price (`prices[i] - prices[i-1]`).
    - If `current_max` is negative, update it to 0 (greedy approach; reset the search for the start of the maximum subarray).
    - If `current_max` is higher than `max_profit`, update `max_profit`.
1. Finally, return `max_profit`.

### Code

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        current_max = max_profit = 0
        for i in range(1, len(prices)):
            current_max += prices[i] - prices[i-1]
            current_max = max(current_max, 0)
            max_profit = max(max_profit, current_max)
        return max_profit
```

### Complexity

- Time complexity: $O(n)$

A single pass `for` loop is used iterate over `prices`.

- Space complexity: $O(1)$

Constant space used (only 2 variables required).
